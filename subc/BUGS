

	UNRESOLVED BUGS


	(1) Submitted by Quan Tran in 10/2015

	Thanks a lot!

	Dont miss his improved Go version of SubC at:
	https://github.com/qeedquan/gosubc

	The SubC bootstrap compiler generated by gcc/clang uses
	4 bytes int, so it will generate wrong code for x86_64
	regarding numbers out of 4 bytes range, so the asm will
	mismatch against the compiler. However, the final scc built
	from the scc0 and scc1 bootstrap will use 8 bytes int on
	x86_64 so that will be correct.

	SubC does not support passing struct/unions as values, but it
	allows you to declare it in function parameters, e.g.:

	void f(struct foo x) {}

	Switch statements may contain duplicate cases.

	SubC allows externs in local declarations to be initialized:

	void f() { extern int a = 10; } /* should not be allowed! */

	SubC can only index using arrays that is of int types, e.g.:
	given
	int  a[10], b[2];
	char x[10];
	a[x[0]] does not work but a[b[0]] does work even though x[0]
	does generate a valid integer index. Workaround: a[x[0]+0],
	which will promote x[0] to int.

	SubC currently allows any unary ops on any types, even on
	structs: e.g.:

	struct file f; !f;


	(2) Submitted by Volkmar Klatt in 08/2016

	Prints wrong result (0) and core-dumps:

	#include <stdio.h>
	int main() {
	  int g = 2;
	  g = (1 < (0, 1));
	  printf("%d\n", g);
	  return 0;
	}

	Prints wrong result (0):
	
	#include <stdio.h>
	int main() {
	  int i = 2;
	  printf("%d\n", (4 || 3) + (i > 1));
	  return 0;
	}

